import os
import sys
import ast
import importlib.util
from util import redo
from database.py_source_database import py_source_database
from base_classes.build_rule_base import build_rule_base
from util import shell


def pydep(source_file, path=[]):
    """
    Return dependencies for a given python source file.
    Two lists are returned to the user. The first list is
    the modules found whose source files actually exist on
    the system. The second list includes modules
    that were found in the source file, but could not be
    found on the file system.
    """
    # If a path is not provided than just use the python
    # path variable:
    if not path:
        path = os.environ["PYTHONPATH"].split(":")

    with open(source_file, "r") as f:
        root = ast.parse(f.read())

    existing_deps = []
    nonexistent_deps = []

    for node in ast.walk(root):
        if isinstance(node, ast.Import):
            for alias in node.names:
                name = alias.name  # name of the module
                spec = importlib.util.find_spec(name)
                # if module (and its origin file) exists, append to the existing_deps
                if spec is not None:
                    if spec.origin is None or spec.origin == "built-in":
                        existing_deps.append(f"built-in:{name}")
                    else:
                        existing_deps.append(spec.origin)
                else:
                    nonexistent_deps.append(name)

        if isinstance(node, ast.ImportFrom):
            name = node.module  # name of the module
            if name:  # if name is not None
                spec = importlib.util.find_spec(name)
                if spec is not None:
                    if spec.origin is None or spec.origin == "built-in":
                        existing_deps.append(f"built-in:{name}")
                    else:
                        existing_deps.append(spec.origin)
                else:
                    nonexistent_deps.append(name)

    return list(set(existing_deps)), nonexistent_deps


def _build_pydeps(source_file, path=[]):
    """
    Recursively build any missing python module dependencies for
    a given source file.
    """
    built_deps = []
    deps_not_in_path = []

    def _inner_build_pydeps(source_file):
        # Find the python dependencies:
        existing_deps, nonexistant_deps = pydep(source_file, path)

        # For the nonexistent dependencies, see if we have a rule
        # to build those:
        if nonexistant_deps:
            deps_to_build = []
            with py_source_database() as db:
                deps_to_build = db.try_get_sources(nonexistant_deps)

            deps_not_in_path.extend(deps_to_build)

            # Don't rebuild anything we have already built:
            deps_to_build = [d for d in deps_to_build if d not in built_deps]

            # Build the deps:
            if deps_to_build:
                redo.redo_ifchange(deps_to_build)
                built_deps.extend(deps_to_build)

                # Run py deps on each of the build source files:
                for dep in deps_to_build:
                    _inner_build_pydeps(dep)

    _inner_build_pydeps(source_file)
    return list(set(deps_not_in_path))


class _build_python_no_update(build_rule_base):
    """
    Class which helps us build the dependencies of a python file using
    the build system.
    """
    def _build(self, redo_1, redo_2, redo_3):
        # Build any dependencies:
        return _build_pydeps(redo_1)


class _build_python(build_rule_base):
    """
    Class which helps us build the dependencies of a python file using
    the build system.
    """
    def _build(self, redo_1, redo_2, redo_3):
        # Build any dependencies:
        deps_not_in_path = _build_pydeps(redo_1)

        # Figure out what we need to add to the path:
        paths_to_add = list(set([os.path.dirname(d) for d in deps_not_in_path]))

        # Add the paths to the path:
        sys.path.extend(paths_to_add)

        return deps_not_in_path


class _run_python(build_rule_base):
    """
    Class which helps us run a python file using the build system.
    This has the major benefit of building all python dependencies that
    are autogenerated prior to running the actual python file to be executed.
    """
    def _build(self, redo_1, redo_2, redo_3):
        # Build any dependencies:
        deps_not_in_path = _build_pydeps(redo_1)

        # Figure out what we need to add to the path:
        paths_to_add = list(set([os.path.dirname(d) for d in deps_not_in_path]))

        # Run the python script:
        shell.run_command(
            "PYTHONPATH=$PYTHONPATH:" + ":".join(paths_to_add) + " python " + redo_1
        )


def build_py_deps(source_file=None, update_path=True):
    # If the source file is none, then use the source file of this function caller:
    if not source_file:
        import inspect

        frame = inspect.stack()[1]
        module = inspect.getmodule(frame[0])
        source_file = module.__file__
    if update_path:
        rule = _build_python()
    else:
        rule = _build_python_no_update()
    deps = rule.build(
        redo_1=source_file,
        redo_2=os.path.splitext(source_file)[0],
        redo_3=source_file + ".out",
    )

    # Reset the database, so that this function can be run again, if warranted.
    import database.setup

    database.setup.reset()

    return deps


def run_py(source_file):
    rule = _run_python()
    rule.build(
        redo_1=source_file,
        redo_2=os.path.splitext(source_file)[0],
        redo_3=source_file + ".out",
    )

    # Reset the database, so that this function can be run again, if warranted.
    import database.setup

    database.setup.reset()


# This can also be run from the command line:
if __name__ == "__main__":
    args = sys.argv[1:]
    verbose = "--verbose" in args or "-v" in args
    if "--verbose" in args:
        args.remove("--verbose")
    if "-v" in args:
        args.remove("-v")

    if not args:
        print("usage:\n  pydep.py [--verbose or -v] /path/to/python_file1.py /path/to/python_file2.py ...")
        sys.exit(1)

    all_existing_deps = set()

    for source_file in args:
        existing_deps, nonexistant_deps = pydep(source_file)
        all_existing_deps.update(existing_deps)

        if verbose:
            print(f"\nFinding dependencies for: {source_file}")
            print("\nExisting dependencies:")
            for dep in existing_deps:
                print(dep)

            print("\nNonexistent dependencies:")
            for dep in nonexistant_deps:
                print(dep)

            print("\nBuilding nonexistent dependencies:")

        build_py_deps(source_file)

    print("\n".join(sorted(all_existing_deps)))
